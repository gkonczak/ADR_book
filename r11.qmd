# Przetwarzanie danych. Pakiet **tidyverse**

::: {.callout-note icon="false" appearance="simple"}


Pakiet **tidyverse** to zbiór  pakietów w języku **R**. Funkcje zawarte w tych pakietach służą do porządkowania, analizy i wizualizacji danych w sposób spójny, czytelny i nowoczesny. Najważniejsze pakiety wchodzące w skład **tidyverse** to:

-   **ggplot2**
-   **dplyr**
-   **tidyr**
-   **readr**
-   **purrr**
-   **tibble**
-   **stringr**
-   **forcats**

W niniejszym rozdziale przedstawiono charakterystykę wskazanych powyżej pakietów wchodzących w skład **tidyverse**. Dla poszczególnych pakietów wskazano najważniejsze funkcje oraz przykłady ich zastosowań.

:::

Pakiet **ggplot2** został scharakteryzowany w roz. 6 i dlatego teraz zostanie pominięty. W zwięzłej formie zostaną przedstawione pozostałe pakiety wchodzące w skład  **tidyverse**. Dla każdego z tych pakietów będą przedstawione przykłady zwracające uwagę na kluczowe ich możliwosci.

W przykładach będzie wykorzystywany operator `pipe`. Operator `pipe` (`%>%`) pochodzi z pakietu **magrittr**, który stał się integralną częścią **tidyverse**. Głównym celem stosowania tego operatora jest poprawienie czytelności kodu poprzez umożliwienie płynnego łączenia wielu operacji na danych w jeden ciąg operacji. Jest to bardzo przydatne w kontekście manipulacji danymi, szczególnie przy użyciu pakietu **dplyr**.

Na wstępie należy załadować niezbędne w tym rozdziale pakiety. Ponieważ omawiane pakiety są składowymi **tidyverse**, to wystarczy załadować jedynie ten pakiet, co realizuje poniższa komenda.

```{r}
library(tidyverse)
```


Poniżej przedstawiono przykład zastosowania opratora `pipe`.

```{r}
#| echo: true
#| results: markup
#| message: false
#| warning: false
dane <- iris %>%  # przekazanie zbioru 'iris' do kolejnej linii
  filter(Species == "setosa") %>%  # wybór obserwacji, gdzie gatunek to 'setosa'
  select(Sepal.Length, Sepal.Width) %>%  # wybór zmiennych
  mutate(Sepal.Area = Sepal.Length * Sepal.Width)  # dodanie kolumny o nazwie 'Sepal.Area'

head(dane)
```

Wielokrotnie w dalszej części będzie wykorzystywany operator `pipe` (`%>%`).


## Pakiet **dplyr**

Jeden z wazniejszych pakietów wchodzących w sklad pakietu **tidyverse** jest **dplyr**. Krótka charakterystyka tego pakietu i wybrane przykłady zastosowań zamieszczono ponizej, a w dalszej części podobne informacje dla pozostałych pakietów.

::: callout-note
## **dplyr**

Pakiet **dplyr** to jeden z najpopularniejszych pakietów w środowisku **R**, używany do pracy z danymi. Należy do rodziny pakietów **tidyverse** i jest zaprojektowany w celu ułatwienia pracy z ramkami danych (data frame) i innymi strukturami danych, takimi jak tibbles.
:::

Najważniejsze i najbardziej przydatne funkcje tego pakietu to:

-   *filter()* – filtrowanie danych na podstawie zadanych warunków.
-   *select()* – Wybór ustalonych kolumn z ramki danych.
-   *mutate()* – dodawanie nowych kolumn do ramki danych lub modyfikacja istniejących.
-   *arrange()* – Sortowanie danych według podanych kolumn.
-   *summarize()* – agregacja danych według określonych mierników.
-   *group_by()* – grupowanie danych na podstawie jednej lub więcej zmiennych.
-   *join()* – łączenie dwóch zakresów danych na podstawie wspólnych kolumn (np. left_join(), inner_join()).

Ponizej przedstawiono przykłady zastosowania wyżej wyminienionych wymienionych funkcji.

- filtrowanie danych

```{r}
#| echo: true
#| results: markup
#| message: false
#| warning: false
dane <- iris %>%
  filter(Species == "setosa", Sepal.Length > 5)
head(dane)
```

- wybór zmiennych

```{r}
dane <- iris %>%
  select(Sepal.Length, Sepal.Width, Species)
head(dane)
```

- konstrukcja nowej zmiennej

```{r}
dane <- iris %>%
  mutate(Sepal.Area = Sepal.Length * Sepal.Width)
head(dane)
```

- sortowanie danych

```{r}
dane <- iris %>%
  arrange(desc(Sepal.Length))
head(dane)
```

- podsumowanie danych

```{r}
dane <- iris %>%
  group_by(Species) %>%
  summarize(
    srednia_dlugosc = mean(Sepal.Length),
    sd_dlugosc = sd(Sepal.Length),
    liczba_obs = n()
  )
dane
```



- agregowanie danych

```{r}
dane <- iris %>%
  group_by(Species) %>%
  summarize(Average_Sepal_Length = mean(Sepal.Length), .groups = "drop")
head(dane)
```

- łączenie danych

```{r}
df1 <- data.frame(ID = 1:3, Value1 = c(10, 20, 30))
df2 <- data.frame(ID = 2:4, Value2 = c(100, 200, 300))

# Łączenie na podstawie wspólnej kolumny ID
dane <- df1 %>%
  left_join(df2, by = "ID")
print(dane)
```


## Pakiet **tidyr**

::: callout-note
## **tidyr**

Pakiet **tidyr** został zaprojektowany do manipulowania danymi w formacie tzw. "czystym" (tidy data). W takim formacie dane są przechowywane w sposób, który ułatwia ich analizowanie i wizualizowanie. Pakiet **tidyr** pozwala na łatwe przekształcanie danych w bardziej użyteczne formy, takie jak "long" i "wide" formats, dzięki czemu praca z nimi staje się prostsza i bardziej przejrzysta.

Najważniejsze funkcje tego pakietu to:

-   *pivot_longer()* - rekonstrukcja danych z szerokiego formatu do długiego,
-   *pivot_wider()* - rekonstrukcja danych z długiego formatu do szerokiego,
-   *separate()* - rozbijanie jednej kolumny na kilka,
-   *unite()* - łączenie wielu kolumn w jedną.
:::

Poniżej przedstawiono przykłady zastosowania wymienionych funkcji.


- zmiana szerokiego układu tabeli na długi

```{r}
library(tidyr)
dane <- data.frame(
  ID = 1:3,
  Jan = c(10, 20, 30),
  Feb = c(40, 50, 60),
  Mar = c(70, 80, 90)
)
dane_long <- dane %>%
  pivot_longer(cols = Jan:Mar, names_to = "Month", values_to = "Value")
dane_long
```

- zmiana długiego układu tabeli na szeroki

```{r}
dane <- data.frame(
  ID = rep(1:3, each = 3),
  Month = c("Jan", "Feb", "Mar", "Jan", "Feb", "Mar", "Jan", "Feb", "Mar"),
  Value = c(10, 40, 70, 20, 50, 80, 30, 60, 90)
)
head(dane)
dane_wide <- dane %>%
  pivot_wider(names_from = "Month", values_from = "Value")
dane_wide
```

- rozdzielenie kolumny

```{r}
dane <- data.frame(
  Name = c("John_Doe", "Jane_Smith", "Sam_Jones")
)
# Rozdzielanie kolumny "Name" na dwie kolumny: "First Name" i "Last Name"
dane <- dane %>%
  separate(Name, into = c("First Name", "Last Name"), sep = "_")
dane
```

- połączenie kolumn

```{r}
dane <- data.frame(
  FirstName = c("Jan", "Piotr", "Anna"),
  LastName = c("Nowak", "Kowalski", "Malinowska")
)
dane <- dane %>%
  unite("FullName", FirstName, LastName, sep = " ")
dane
```



## Pakiet **readr**


::: callout-note
## **readr**

Pakiet **readr** jest częścią środowiska **tidyverse**. Został zaprojektowany w celu szybkiego i wygodnego wczytywania danych z różnych plików tekstowych, szczególnie z plików CSV, TSV, i innych popularnych formatów. Wybrane funkcje:

*read_csv()* – Wczytywanie danych z pliku CSV,

*read_tsv()* – Wczytywanie danych z pliku TSV, 

*read_delim()* – Wczytywanie danych z pliku z niestandardowym separatorem.
:::

Poniżej przedstawiono przykłady zastosowań wskazanych funkcji.

- *read_csv()*


```{r}
# library(readr)
```

Odczyt danych zapisanych w formacie *.csv może być zrealizowany z wykorzystaniem funkcji `read_csv()`.

```{r}
#| warning: false
#| echo: true
#| eval: false
# Wyniki realizacji poniższego kodu nie są wyświetlane
dane <- read_csv("plik.csv") # Wczytanie danych z pliku CSV
dane 
```

Dane mogą  być wprowadzane z dysku lokalnego, ale również można odczytywać dane dostępne on-line.

```{r}
# Odczyt danych on-line w formacie CSV.
dane <- read_csv("https://raw.githubusercontent.com/plotly/datasets/master/iris.csv")
dane
```


- *read_delim()*

Przy odczycie danych tekstowych możliwe jest deklarowanie separatora kolumn, jak w ponizszym przykładzie.

```{r}
#| warning: false
#| echo: true
#| eval: false
# Wyniki realizacji poniższego kodu nie są wyświetlane
dane <- read_delim("plik.txt", delim = ";") # Wczytanie danych z pliku z niestandardowym separatorem
dane
```



## Pakiet **purrr**


::: callout-note 
## **purrr**

Pakiet **purrr** dostarcza funkcje do pracy z funkcjami i iteracjami w sposób bardziej funkcjonalny. Głównym celem **purrr** jest uproszczenie pracy z funkcjami, szczególnie w kontekście przetwarzania danych i iteracji, zastępując tradycyjne pętle for i apply.

:::

Poniżej przedstawiono przykłady zastosowania wybranych funkcji pakietu **purrr**

Pierwszy przykład dotyczy mapowania funkcji  `sqrt` do każdego elementu wektora. 

```{r}
#| warning: false
#| echo: true
#| eval: true
# library(purrr)
x <- c(1, 4, 9, 16)
wynik <- map(x, sqrt)
wynik
```

Kolejny przykład wskazuje mozliwość zastosowania funkcji do obliczenia sumy kwadratów do elementów dwóch wektorów.

```{r}
#| warning: false
#| echo: true
#| eval: true

x <- c(1, 2, 3)
y <- c(4, 5, 6)
wynik <- map2(x^2, y^2, sum)
wynik
```

Ostatni z przykładów dotyczy zastosowania `pmap()` do obliczania sumy funkcji odpowiadających sobie elementów trzech wektorów

```{r}
#| warning: false
#| echo: true
#| eval: true

x <- c(1, 2, 3)
y <- c(4, 5, 6)
z <- c(7, 8, 9)
wynik <- pmap(list(x^3, y^2, sqrt(z)), sum)
wynik
```


## Pakiet **tibble**

::: callout-note
## **tibble**

Pakiet **tibble** oferuje rozszerzenie tradycyjnej klasy danych ramka danych (data.frame). Tibble to nowoczesna wersja data.frame, która poprawia niektóre ograniczenia tej klasy, czyniąc pracę z danymi bardziej intuicyjną i wydajną. Głównym celem pakietu tibble jest ułatwienie pracy z danymi.
Najważniejsze funkcje tego pakietu to:

-   *tibble()* - utworzenie obiektu tibble z nazwami kolumn jako argumenty funkcji. Kolumny mogą zawierać różne typy danych, takie jak liczby zmiennoprzecinkowe, łańcuchy znaków czy całkowite,
-   *as_tibble()* - konwersja obiektu data.frame do tibble,
-   *tribble()* – konstrukcja tibble z danych w formie tekstowej,
-   *glimpse()* – podgląd danych w tibble.
:::

Poniżej przedstawiono przykłady zastosowań wskazanych funkcji.

- utworzenie tibble

```{r}
# library(tibble)
dane <- tibble(
  Name = c("Anna", "Piotr", "Zofia"),
  Age = c(25, 30, 22),
  Score = c(88.5, 91.3, 79.8)
)
dane
```

- konwersja z data.frame na tibble

```{r}
df <- data.frame(
  Name = c("Anna", "Piotr", "Zofia"),
  Age = c(25, 30, 22),
  Score = c(88.5, 91.3, 79.8)
)
dane <- as_tibble(df)
dane
```

- konwersja danych tekstowych na tibble

```{r}
dane <- tribble(
  ~Name, ~Age, ~Score,
  "Anna", 25, 88.5,
  "Piotr", 30, 91.3,
  "Zofia", 22, 79.8
)
dane
```

- podgląd danych z tibble

```{r}
glimpse(dane)
```

## Pakiet **stringr**


::: callout-note
## **stringr**

Pakiet **stringr** został zaprojektowany w celu ułatwienia pracy z danymi tekstowymi. Oferuje zestaw funkcji, które pozwalają na łatwą manipulację tekstami, w tym wyszukiwanie, zamianę, ekstrakcję i modyfikację ciągów znaków.
Najważniejsze funkcje tego pakietu to:

-   *str_length()* – długość ciągu znaków,
-   *str_sub()* – wyodrębnianie podciągu,
-   *str_detect()* – wyszukiwanie wzorca,
-   *str_replace()* - zamiana tylko pierwszego wystąpienia wzorca,
-   *str_replace_all()* - zamiana wszystkich wystąpień wzorca.

:::

Poniżej przedstawiono przykłady zastosowania wskazanych funkcji.

- długość ciągu znaków

```{r}
# library(stringr)
tekst <- "Analiza danych z programem R"
długość <- str_length(tekst)
długość
```

- wyodrębnienie podciagu znaków

```{r}
fragment <- str_sub(tekst, start = 9, end = 16)
fragment
```

- wyszukiwanie wzorca

```{r}
# Sprawdzanie, czy ciąg zawiera słowo "world"
zawartość <- str_detect(tekst, "programem")
zawartość
```

- zamiana pierwszego  i wszystkich wystąpień wzorca

```{r}
nowy_tekst <- str_replace(tekst, "a", "A")
nowy_tekst
nowy_tekst2 <- str_replace_all(tekst, "a", "A")
nowy_tekst2
```

## Pakiet **forcats**


::: callout-note
## **forcats**

Pakiet **forcats** został zaprojektowany dla ułatwienia pracy z danymi jakosciowymi, szczególnie z czynnikami (ang. factors). Pakiet dostarcza funkcje, które pozwalają na manipulację, modyfikowanie i porządkowanie zmiennych jakościowych w sposób bardziej intuicyjny i spójny w porównaniu do tradycyjnych operacji na czynnikach w **R**.
Najważniejsze funkcje tego pakietu to:

-   fct_inorder() – tworzenie czynników na podstawie kolejności,
-   fct_reorder() – zmiana porzadku poziomów faktora na podstawie innej zmiennej,
-   fct_colllapse() – łączenie poziomów czynnika,
-   fct_rev() – odwracanie kolejności poziomów,
-   fct_expand() – dodawanie nowych poziomów do czynnika.
:::

Przykłady zastosowań:

```{r}
# library(forcats)
dane <- c("mały", "średni", "duży", "średni", "mały")
factors <- fct_inorder(dane)
factors
```

```{r}
# Zmiana poziomów czynnika na podstawie zadanych wartości   
dane <- data.frame(
  kategoria = c("B", "A", "C", "B", "A"),
  wartość = c(2, 5, 3, 7, 3)
)
dane$kategoria <- fct_reorder(dane$kategoria, dane$wartość)
dane
```

```{r}
# Łączenie poziomów faktora
dane <- factor(c("A", "B", "C", "B", "A", "C", "B"))
dane_gr <- fct_collapse(dane, gr1 = c("A", "B"), gr2 = "C")
dane_gr
```

```{r}
# Odwracanie kolejności poziomów
dane <- factor(c("A", "B", "C", "B", "A", "C"))
dane

dane_2 <- fct_rev(dane)
dane_2

```

```{r}
# Dodawanie nowych poziomów do faktora
dane <- factor(c("A", "B", "A"))
dane_2 <- fct_expand(dane, "C", "D")
dane_2

```


::: callout-caution
## Ćwiczenia do samodzielnego wykonania

1. Wybierz samochody z **mtcars**, które mają więcej niż 150 koni mechanicznych (hp > 150) i posortuj je według mpg (w porządku malejącym).

2. Użyj funkcji pivot_longer() z pakietu **tidyr**, aby przekształcić dane z szerokiego formatu do formatu długiego dla danych **mtcars**, wybierając tylko kolumny *mpg*, *hp*, i *wt*.

3. Wczytaj dane z pliku CSV (np. data.csv) do ramki danych w **R**, używając funkcji read_csv().

4. Użyj funkcji `map()` z pakietu **purrr** do obliczenia średniej dla każdej kolumny w ramce danych **mtcars**.

5. Użyj funkcji `fct_lump()` z pakietu **forcats** do zgrupowania kategorii zmiennej cyl (liczba cylindrów) w mniejsze grupy (np. 2 najczęstsze i reszta jako "Inne").


:::


